<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Chloe">


    <meta name="subtitle" content="有些人能收到雨，而其他则只是被淋湿。">




<title>wuzhihua | Chloe&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    


<meta name="generator" content="Hexo 4.2.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Chloe&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">Categories[分类]</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Chloe&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">Categories[分类]</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">wuzhihua</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Chloe</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">July 2, 2020&nbsp;&nbsp;10:31:30</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>目前分布式小文件系统方案：</p>
<ol>
<li><p>应用读取本地历史文件，走小文件系统的API接口写入到OSS环境。</p>
</li>
<li><p>需要开通网络，创建oss小文件系统的存储用户。</p>
</li>
<li><p>原生到分布式小文件系统的压缩率有多少，CRM对heap的贡献值有多少，</p>
</li>
<li><p>迁移程序，数据抽查查询</p>
</li>
<li><p>namenode节点十分重要。</p>
</li>
<li><p>将历史数据</p>
</li>
<li><p>倒排时间：</p>
</li>
<li></li>
<li><p>测试范围/内容，哪些测试点，哪些性能指标值，</p>
</li>
<li><p>每天邮件汇报进度</p>
</li>
</ol>
<ol>
<li>nn和dn需要分离：</li>
<li>测试小文件系统的使用：</li>
<li>历史数据迁移到oss——应用：迁移程序，数据一致性抽样调查</li>
</ol>
<ol>
<li>需要查看哪些是hbase持久化的数据，哪些是hdfs直接上传的数据文件。数据量大小，来评估需要迁移多大的数据量，除以福</li>
</ol>
<p>小文件restful上传测试：<br>原生直连hbase</p>
<p>之前应用吴橙描述：双写无纸化集群<br>1、pdf通过原生hdfs的客户端直连，一定会有相关的账号密码做上传，有目录的写权限一定有删除权限，hdfs就是文件系统和数据库不一样，没有单独的权限分离。这里简称【hdfs上传程序】<br>2、同时多个pdf合并后上传hbase，落地无纸化集群。这里简称为【hbase合成程序】</p>
<p>（2019.6）之前应用修改过业务逻辑，pdf合成后，在【hdfs上传程序】中保存的pdf小文件不删除。</p>
<p>6月30日删除了27.6T的数据<br>–2016年之前的数据<br>/e_ffcsanms/eoffice/pdf/2016  </p>
<p>–2019年7月到12月数据<br>/e_ffcsanms/eoffice/pdf/phone/2019/07/* 到 /e_ffcsanms/eoffice/pdf/phone/2019/12/*</p>
<p>/e_ffcsanms/eoffice/pdf/first/2019/07/* 到 /e_ffcsanms/eoffice/pdf/first/2019/12/*</p>
<p>/e_ffcsanms/eoffice/pdf/third/2019/07/* 到 /e_ffcsanms/eoffice/pdf/third/2019/12/*</p>
<p>/e_ffcsanms/eoffice/pdf/combine/2019/07/* 到 /e_ffcsanms/eoffice/pdf/combine/2019/12/*</p>
<p>/e_ffcsanms/eoffice/pdf/combineapp/2019/07/* 到 /e_ffcsanms/eoffice/pdf/combineapp/2019/12/*</p>
<p>/e_ffcsanms/eoffice/pdf/second/2019/07/* 到 /e_ffcsanms/eoffice/pdf/second/2019/12/*</p>
<p>/e_ffcsanms/eoffice/pdf/contentStr/2019/07/* 到 /e_ffcsanms/eoffice/pdf/contentStr/2019/12/*</p>
<p>/e_ffcsanms/eoffice/pdf/complete/2019/07/* 到 /e_ffcsanms/eoffice/pdf/complete/2019/12/*</p>
<h1 id="中国电信江苏公司信息化应用系统开发规范-2020年试行版"><a href="#中国电信江苏公司信息化应用系统开发规范-2020年试行版" class="headerlink" title="中国电信江苏公司信息化应用系统开发规范(2020年试行版)"></a><center>中国电信江苏公司信息化应用系统开发规范(2020年试行版)</center></h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>为了推进IT系统全面上云，提升系统性能、可用性、可维护性，降低系统复杂度，避免重复建设、实现降本增效，指导解决江苏公司信息化应用软件开发设计中遇到的问题。该规范从容器化部署、操作系统基础设施、用户交互、代码实现、中间件使用、运维规范性等方面作出指导与要求,提供需要遵循的原则和方法。</p>
<h2 id="第一部分：可用性保障"><a href="#第一部分：可用性保障" class="headerlink" title="第一部分：可用性保障"></a>第一部分：可用性保障</h2><h3 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h3><ul>
<li>各关键节点虚拟化，以避免受到个别硬件故障的影响。</li>
<li>避免将节点集中部署在一个可用区内（单个硬件的承载范围），但系统很多、资源有限无法避免时，应通过容器部署等技术确保能够在数分钟内于全新环境下重新部署。</li>
<li>应确保在业务高峰时一个节点退出服务后其余节点仍能承担全部负载，否则会导致雪崩</li>
</ul>
<h3 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h3><p>服务调用主要通过3种方式来实现：</p>
<ul>
<li>API网关，比如Nginx、EOP，中心化模式，只要有前端就绕不过去</li>
<li>P2P，比如Dubbo，去中心化模式，主要应用在相对大型系统的内部</li>
<li>Service Mesh，将服务能力的提供从框架移到中间件</li>
</ul>
<h3 id="服务注册和服务发现"><a href="#服务注册和服务发现" class="headerlink" title="服务注册和服务发现"></a>服务注册和服务发现</h3><p>服务注册和发现实现了服务消费者和调用者之间解耦，服务的提供者新增和减少机器不用邮件挨个去通知调用者，说我们再什么时间割接，请你配合下。服务的注册和发现有两种方式：1. 自服务式；2代理式</p>
<ul>
<li><p>自服务式<br>服务提供者自己到服务注册中心注册自己的地址，消费者通过服务注册中心查询服务提供的地址。<br><img src="media/15839090412890/15844351952255.png" alt="-w244"></p>
</li>
<li><p>代理式<br>服务提供者自己到服务注册中心注册自己的地址或者通过配置在负载均衡上事先配置好地址，消费者通过服务注册中心查询服务提供的地址。<br><img src="media/15839090412890/15844352092654.png" alt="-w352"></p>
</li>
</ul>
<p><font color=red size=4>必须：</font><br>为了实现应用的弹性伸缩，建议每个应用都实现服务的自注册。一般通过zk,consul,etcd来支撑。如果是spring cloud也可以使用Eureka.</p>
<h3 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h3><p>为了保障后端服务正常可用，一般通过健康检查来实现。通过服务调用的主被动故障检测。故障检测与负载均衡联动，以自动快速剔除故障节点。仅检测操作系统/AppServer状态和网络响应往往无法发现服务能力已经丧失的故障节点。</p>
<p><font color=red size=4>必须：</font><br>健康检查一般有两种方式：服务注册中心主动探测和服务提供者通过心跳方式主动上报。小型系统两种方式都行，大型系统建议采用心跳方式来进行监控。</p>
<p><font color=red size=4>必须：</font><br>防止服务过度摘除：如果摘除的节点占到了服务集群节点数的40%，就停止摘除服务节点，并且给服务的开发同学和运维同学报警处理（阈值可根据实际情况调整）</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>设置合理的分发机制以保证各节点负载均衡。考虑到单笔业务的负载和节点处理能力可能不一致，简单的轮询往往不能保证负载平衡，根据业务属性、来源IP等分发可能导致严重不均衡。</p>
<p><font color=red size=4>必须：</font><br>最少连接数：客户端同服务端节点的连接数是在时刻变化的，理论上连接数越少代表此时服务端节点越空闲，选择最空闲的节点发起请求，能获取更快的响应速度。尤其在服务端节点性能差异较大，而又不好做到预先定义权重时，采用最少活跃连接算法是比较好的选择。</p>
<p><font color=green size=4>可选：</font><br>最快响应速度：在去中心化的服务调用框架中，负载均衡是在客户端进行的、这时可以考虑最快响应速度算法，即调整返回最快服务端的权重。</p>
<p><font color=red size=4>必须：</font><br>防止流量的震荡：无论是最小连接还是最快返回算法，如果在调整时将所有的流量都打到认为是最小负载的服务器，必然会导致这台服务器的过载。因此可以考虑在计算出理想的权重后，将实际执行的权重偏移步长的1/4。比如：有3台服务器，经过计算权重为 3,3,3.经过计算，其中一台服务器的权重应当调整为5。那么实际执行时建议先调整为3,3,3.5。</p>
<h3 id="长连接管理"><a href="#长连接管理" class="headerlink" title="长连接管理"></a>长连接管理</h3><p><font color=red size=4>必须：</font><br>系统内的高频接口调用一般使用长连接的方式。</p>
<ul>
<li>长连接应定时检测是否有效，如有可能发生资源泄漏或僵死应定期轮换释放重连。</li>
<li>大量A节点连接到大量B节点时，应将AB节点分组连接，以控制连接数，并定期轮换保持负载均衡。例如：30个A节点访问30个B节点，如果不分组，每个A节点建立20个连接，将会使每个节点保持600个连接。</li>
<li>设置合理的连接数上限。连接数异常暴增时加大连接数无助于问题解决只会导致服务提供方和其他服务使用方的连续崩溃。</li>
<li>需要较长时间才能完成的处理，应采取异步方式从而避免连接数暴增。</li>
</ul>
<h3 id="限流降级"><a href="#限流降级" class="headerlink" title="限流降级"></a>限流降级</h3><p>限流的目的是保护系统不会在过载的情况下出现问题。限流的相关的策略一般是，一旦达到限制的速率，那么就会触发相应的行为。</p>
<p><font color=red size=4>必须：</font><br><strong>拒绝服务：</strong>把多出来的请求拒绝掉。一般来说，好的限流系统在受到流量暴增时，会统计当前哪个客户端来的请求最多，直接拒掉这个客户端，这种行为可以把一些不正常的或者是带有恶意的高并发访问挡在门外。</p>
<p><font color=red size=4>必须：</font><br><strong>服务降级：</strong>关闭或是把后端服务做降级处理。这样可以让服务有足够的资源来处理更多的请求。降级有很多方式，一种是把一些不重要的服务给停掉，把 CPU、内存或是数据的资源让给更重要的功能；一种是不再返回全量数据，只返回部分数据。因为全量数据需要做 SQL Join 操作，部分的数据则不需要，所以可以让 SQL 执行更快，还有最快的一种是直接返回预设的缓存，以牺牲一致性的方式来获得更大的性能吞吐。<br>伴随着服务降级，一般会有相应的业务及技术方案，比如：</p>
<ul>
<li>不因营销建议无法获取而阻止客户定位和业务办理。</li>
<li>选址服务故障时暂时填写非结构化地址。</li>
<li>当认证系统故障时，延迟令牌更新而不中断用户使用。</li>
<li>服务列表无法获取时，继续使用本地缓存的旧列表。</li>
<li>当发现备用库连续多次写入失败时，暂时只使用主库。</li>
</ul>
<p><font color=green size=4>可选：</font><br><strong>特权请求:</strong>所谓特权请求的意思是，资源不够了，我只能把有限的资源分给重要的用户，比如：分给权利更高的 VIP 用户。在多租户系统下，限流的时候应该保大客户的，所以大客户有特权可以优先处理，而其它的非特权用户就得让路了。</p>
<h3 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h3><p><font color=green size=4>可选：</font><br><strong>漏桶算法</strong><br>漏斗算法的本质就是像漏斗一样，限制流出的最大速率。当访问流量过大时这个漏斗中就会积水，如果水太多了就会溢出。一般来说，这个“漏斗”是用一个队列来实现的，当请求过多时，队列就会开始积压请求，如果队列满了，就会开拒绝请求。很多系统都有这样的设计，比如 TCP。当请求的数量过多时，就会有一个 sync backlog 的队列来缓冲请求，或是 TCP 的滑动窗口也是用于流控的队列。<br><img src="media/15839090412890/15850396622146.png" alt="-w431"></p>
<p>漏桶算法其实就是在队列请求中加上一个限流器，来让 Processor 以一个均匀的速度处理请求。<br><img src="media/15839090412890/15850396740387.png" alt="-w429"></p>
<p><font color=red size=4>必须：</font><br><strong>令牌桶算法</strong><br>令牌桶算法，主要是有一个中间人。在一个桶内按照一定的速率放入一些 token，然后，处理程序要处理请求时，需要拿到 token，才能处理；如果拿不到，则不处理。<br><img src="media/15839090412890/15850397770139.png" alt="-w404"></p>
<p>从理论上来说，令牌桶的算法和漏斗算法不一样的是，漏斗算法中，处理请求是以一个常量和恒定的速度处理的，而令牌桶算法则是在流量小的时候“攒钱”，流量大的时候，可以快速处理。令牌桶和漏桶相比，更具有弹性，允许出现突发流量传递到后端服务的情况。当然，它们都各有利弊，你可以根据自己的情况来选择使用。</p>
<p><font color=green size=4>可选：</font><br><strong>基于响应时间动态限流</strong><br>除了漏桶和令牌桶之外，我们还可以选择基于响应时间的动态限流。令牌桶和漏桶的缺点在于需要事先设置一个确定的限流值。这个值往往需要通过性能测试来寻找，但是随着业务的变化单个系统的极限值也会发生变化，往往我们并不知道这个限流值。另外，现在的服务都是能自动化伸缩的，所以要考虑动态地调整限流的阈值。<br>这里我们采用服务响应时间作为度量指标，计算一个时间区间内（比如10秒）的请求计算一个响应时间的 P90 或 P99 值，如果这个 P90 或 P99 超过设定的阈值，就自动限流。</p>
<h3 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h3><p>重试是一个在服务化调用中常见的机制。</p>
<p><font color=red size=4>必须：</font><br><strong>定义重试的状态码</strong><br>重试的语义是：我们认为这个故障是暂时的，而不是永久的，所以，我们会去重试。重试常见的原因有：调用超时、被调用端返回了某种可以重试的错误（如繁忙中、流控中、维护中、资源不足等）。而对于业务级的错误就不应当发起重试。通过返回码来区分哪些场景需要自动重试，哪些场景需要直接回给客户端。</p>
<p><font color=red size=4>必须：</font><br><strong>熔断</strong><br>在长连接场景下，多次重试失败后，应通过熔断的方式将服务节点标记为故障，避免不断发起新的请求。</p>
<p><font color=red size=4>必须：</font><br><strong>重试最大值</strong><br>如果经过重试还是没有正常返回，就没有必要再重试了，应该报故障了。一般单个请求重试次数不超过<strong>3</strong>次。同时我们应当计算当前时间片内重试数量与服务请求数的占比，如果重试的占比过大（比如30%）那么应当放弃重试。</p>
<p><font color=red size=4>必须：</font><br><strong>指数级退让</strong><br>在重试过程中，每一次重试失败时都应该休息一会儿再重试，这样可以避免因为重试过快而导致网络上的负担加重。比如我们设置指数为2，每多一次重试就需要多等一段时间。如：第一次等 200ms，第二次要 400ms，第三次要等 800ms……</p>
<p><font color=green size=4>可选：</font><br><strong>随机指数退让</strong><br>在指数退让的基础上引入随机乘数，固定乘数可能会引起很多服务同时重试导致 DDos，使用随机休眠时间来避免这种情况。</p>
<h3 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h3><p>幂等就是伴随的重试了。常见的触发原因除了网关上的重试，消息队列上的重复信息还包括用户在客户端发起重试。对幂等的支持应当视为提供服务的标准操作。</p>
<p><font color=red size=4>必须：</font><br><strong>全局id</strong><br>要做到幂等性的交易接口，需要有一个唯一的标识，来标志交易是同一笔交易，这个标识要能做到全局唯一。常见的全局id算法有UUID和SnowFlake，雪花算法会更好一点：1.占用的空间比较小;2.有一定的可读性，有一定的时间表现。</p>
<p><font color=red size=4>必须：</font><br><strong>利用数据库的唯一约束实现幂等</strong><br>例如在数据库中建一张流水表，这个表包括交易ID，限制交易ID唯一，这样同一个交易只能插入一条记录，后续重复的插入操作都会失败，这样就实现了一个幂等的操作。基于这个思路，不光是可以使用关系型数据库，只要是支持类似“INSERT IF NOT EXIST”语义的存储类系统都可以用于实现幂等，比如，可以用 Redis 的 SETNX 命令来替代数据库中的唯一约束，来实现幂等。</p>
<p><font color=red size=4>必须：</font><br><strong>通过版本号解决ABA问题</strong><br>什么是ABA问题：比如说，订单支付之后，小二要发货，发货完成后要填个快递单号。假设说，小二填了一个单号 666，刚填完，发现填错了，赶紧再修改成 888。对订单服务来说，这就是 2 个更新订单的请求。正常情况下，订单中的快递单号会先更新成 666，再更新成 888，这是没问题的。那不正常情况呢？666 请求到了，单号更新成 666，然后 888 请求到了，单号又更新成 888，但是 666 更新成功的响应丢了，调用方没收到成功响应，自动重试，再次发起 666 请求，单号又被更新成 666 了。</p>
<p><img src="media/15839090412890/15851244749052.jpg" alt="-w333"></p>
<p>ABA问题的通用接是在表中增加version，每次查询时版本号要返回客户端，然后客户端带着version更新数据。<br><img src="media/15839090412890/15851259267614.jpg" alt="-w565"></p>
<h2 id="第二部分：高并发"><a href="#第二部分：高并发" class="headerlink" title="第二部分：高并发"></a>第二部分：高并发</h2><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>一般来说遇到性能问题，尤其是数据库性能问题，都首先会想到缓存。缓存，是一种存储数据的组件，它的作用是让对数据的请求更快地返回。通常来说我们会把缓存放在内存中来存储。<br>这里我们讲的缓存方案指的是集中式的远程缓存。<br><img src="media/15839090412890/15840053598538.jpg" alt="-w520"></p>
<h4 id="缓存的读写策略"><a href="#缓存的读写策略" class="headerlink" title="缓存的读写策略"></a>缓存的读写策略</h4><p><font color=red size=4>必须：</font></p>
<p>采用<code>Cache Aside</code>策略<br><img src="media/15839090412890/15858770966477.jpg" alt="-w347"></p>
<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>缓存要防止当大量的缓存失效或者恶意读取，导致压力全部穿透到数据库，造成数据库瞬间压力过大。</p>
<p><font color=red size=4>必须：</font><br>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生</p>
<p><img src="media/15839090412890/15844117500934.jpg" alt="-w347"></p>
<h4 id="缓存高可用"><a href="#缓存高可用" class="headerlink" title="缓存高可用"></a>缓存高可用</h4><p><font color=red size=4>必须：</font></p>
<p>对于redis，需要采用主从部署模式，并通过<code>sentinel</code>来解决主从redis的高可用，实现主节点挂了后自动将从节点升级为主节点，保证整体集群的可用。</p>
<p><img src="media/15839090412890/15843456796342.jpg" alt="-w598"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes </span><br><span class="line">port 7505</span><br><span class="line">#指定工作目录</span><br><span class="line">dir &quot;&#x2F;usr&#x2F;local&#x2F;redis-sentinel&#x2F;7505&quot;</span><br><span class="line">logfile &quot;.&#x2F;sentinel.log&quot; </span><br><span class="line">#指定别名  主节点地址  端口  哨兵个数（有几个哨兵监控到主节点宕机执行转移）</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 7501 2</span><br><span class="line">#如果哨兵3s内没有收到主节点的心跳，哨兵就认为主节点宕机了，默认是30秒  </span><br><span class="line">sentinel down-after-milliseconds mymaster 3000</span><br><span class="line">#选举出新的主节点之后，可以同时连接从节点的个数</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line">#如果10秒后,master仍没活过来，则启动failover,默认180s  </span><br><span class="line">sentinel failover-timeout mymaster 10000 </span><br><span class="line">#配置连接redis主节点密码  </span><br><span class="line">sentinel auth-pass mymaster 123456</span><br></pre></td></tr></table></figure>


<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列是一个很常见的中间件，主要有以下用途：</p>
<ol>
<li>异步处理。通过异步处理系统可以更快地返回结果，减少等待，提升系统总体吞吐量。</li>
<li>流量控制。根据下游的处理能力自动调节流量，达到“削峰填谷”的作用。</li>
<li>服务解耦。避免下游系统的可用性、性能影响上游系统，避免不断的修改接口。</li>
<li>触发定时检查。比如通过延时队列，检查分布式事务的完整性，进行业务补偿，查看系统是否延时等等。</li>
</ol>
<p><font color=red size=4>必须：</font><br><strong>消息不丢失</strong><br>这里以kafka为例来讲下消息不丢失的配置：</p>
<ol>
<li>不要使用<code>producer.send(msg)</code>，而要使用<code>producer.send(msg, callback)</code>。一定要使用带有回调通知的<code>send</code>方法。</li>
<li>设置<code>acks = all</code>，表明所有副本<code>Broker</code>都要接收到消息，该消息才算是“已提交”。</li>
<li>设置<code>retries</code>为一个较大的值。当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了<code>retries &gt; 0</code>的<code>Producer</code>能够自动重试消息发送，避免消息丢失。</li>
<li>设置<code>unclean.leader.election.enable = false</code>。<code>Broker</code>端的参数，它控制的是哪些<code>Broker</code>有资格竞选分区的<code>Leader</code>。如果一个<code>Broker</code>落后原先的<code>Leader</code>太多，那么它一旦成为新的<code>Leader</code>，必然会造成消息的丢失。故一般都要将该参数设置成<code>false</code>，即不允许这种情况的发生。</li>
<li>设置<code>replication.factor &gt;= 3</code>。<code>Broker</code>端的参数。最好将消息多保存几份，目前防止消息丢失的主要机制就是冗余。</li>
<li>设置<code>min.insync.replicas &gt; 1</code>。<code>Broker</code>端参数，控制的是消息至少要被写入到多少个副本才算是“已提交”。设置成大于<code>1</code>可以提升消息持久性。在实际环境中千万不要使用默认值<code>1</code>。</li>
<li>确保<code>replication.factor &gt; min.insync.replicas</code>。如果两者相等，只要有一个副本挂机，整个分区就无法正常工作了。推荐设置成 <code>replication.factor = min.insync.replicas + 1</code>。</li>
<li>确保消息消费完成再提交。设置<code>enable.auto.commit = false</code>。<code>Consumer</code>端参数，并采用手动提交位移的方式，这对于单<code>Consumer</code>多线程处理的场景而言是至关重要的。</li>
</ol>
<p><font color=green size=4>可选：</font><br><strong>顺序消费</strong><br>顺序消费这种场景的原因是后续消息对前置消息有依赖关系，比如产品依赖于账户。要保障顺序消费并兼顾性能有以下建议。</p>
<ul>
<li>按照核心依赖关系进行分区以提高执行效率，比如档案接口可以按客户ID+核心产销品ID分区</li>
<li>每个topic单线程处理</li>
<li>采用ack等机制确保消息不丢失及数据发送的和处理的有序</li>
<li>处理失败时不要放入重试队列，建议根据业务放到失败区，并且将后续相关的消息进行人工处理</li>
</ul>
<p><font color=red size=4>必须：</font><br><strong>消息限流</strong><br>消息队列也是有底线的，当消费端处理的太慢，生产端拼命的发消息也是不行的。</p>
<ol>
<li>对生产消息通过令牌桶进行限流</li>
<li>对消息队列进行监控，对队列的积压趋势进行告警</li>
<li>当队列积压时，通知生产者不要再发消息了</li>
</ol>
<h2 id="第三部分：监控"><a href="#第三部分：监控" class="headerlink" title="第三部分：监控"></a>第三部分：监控</h2><p>系统上线前应将监控指标、日志和告警策略、派单策略加载到端到端运营监控平台，确保所有节点都纳入监控，并与基础设施维护团队约定各类资源（CPU、内存、网络流量、延迟、存储空间等）的监控指标和告警策略。</p>
<p><img src="media/15839090412890/15862484171422.jpg" alt="-w196"></p>
<p>监控一般分成三种，</p>
<ul>
<li><strong>Metric</strong>。Metric是可累加的：他们具有原子性，每个都是一个逻辑计量单元，或者一个时间段内的柱状图。 例如：队列的当前深度可以被定义为一个计量单元，在写入或读取时被更新统计； 输入HTTP请求的数量可以被定义为一个计数器，用于简单累加； 请求的执行时间可以被定义为一个柱状图，在指定时间片上更新和统计汇总。</li>
<li><strong>Logging</strong>。logging描述一些离散的（不连续的）事件。 例如：应用通过一个滚动的文件输出debug或error信息，并通过日志收集系统，存储到Elasticsearch中； 审批明细信息通过Kafka，存储到数据库（BigTable）中； 又或者，特定请求的元数据信息，从服务请求中剥离出来，发送给一个异常收集服务，如NewRelic。</li>
<li><strong>tracing</strong>。tracing在单次请求的范围内，处理信息。 任何的数据、元数据信息都被绑定到系统中的单个事务上。 例如：一次调用远程服务的RPC执行过程；一次实际的SQL查询语句；一次HTTP请求的业务性ID。</li>
</ul>
<p><font color=red size=4>必须：</font><br><strong>APP监控</strong>用户侧的监控通常从以下几个维度进行，这些监控数据既可以通过打点的方式，也可以通过定期回收日志的方式收集。</p>
<ul>
<li>常见内容：访问资源,访问量,访问成功率,响应时间（包括渲染）,发包回包时间（不包括渲染）,主机类型,操作系统版本,app版本,返回码,网络类型等等。</li>
<li>关注系统崩溃或系统异常类的日志，以求第一时间监控到系统故障。</li>
<li>设备表现监控，主要指对 CPU、内存、温度等的监控，以及一些页面级的卡顿或白屏现象；或者是直接的堆栈分析等。</li>
<li>唯一用户 ID 的监控。用户侧的监控一定要具备针对唯一用户 ID 的监控能力，能够获取某一个独立用户的具体情况。</li>
</ul>
<p><font color=red size=4>必须：</font><br><strong>应用日志监控</strong>。现在的应用服务大都是集群化的，通过日志的归集、索引和展示可以将应用日志有效地联合，并进行分析，也可以起到同样的应用监控作用。常规的监控套路是elk。<br>    - 监控平台提供通用的日志采集和展示服务，及其平台的管理<br>        - 通用的日志采集点包括：nginx日志，log4j日志等<br>        - 采集方式包括：filebeat<br>        - 通用的监控索引包括：nginx日志，log4j日志等<br>    - 通用组件索引由平台提供其索引定义（也可以是模板）<br>    - 对于业务的日志索引由业务系统自己负责数据的清洗的索引的定义<br>    - 业务系统应当100%的跨系统服务调用、一定比例（10%）的内部调用应记录服务响应时间、返回错误代码。<br>    - 业务系统应当完整记录系统报错日志。避免吞日志<br>    - 业务系统使用日志文件记录时应当采用采用循环写入的方式，避免日志量暴增或数据未被及时清理、转移的情况下耗尽空间。</p>
<p><font color=red size=4>必须：</font><br><strong>系统监控</strong>。指的是对基础设施的监控。我们通常会收集 CPU、内存、I/O、磁盘、网络连接等作为监控指标。对于系统监控的指标，我们通常采用定期采样的方式进行采集，一般选取 1 分钟、3 分钟或 5 分钟的时间间隔，但一般不会超过 5 分钟，否则监控效果会因为间隔时间过长而大打折扣。</p>
<p><font color=red size=4>必须：</font><br><strong>Metrics监控</strong>。指的是对系统的监控指标就行汇聚监控，一般建议通过时间序列数据库存放。</p>
<ul>
<li>metrics原始指标的采集可以由业务系统等直接吐出，采集方式可以是拉模式也可以是推模式。一般建议拉模式。</li>
<li>metrics原始指标的采集也可以从调用链监控中根据监控信息定义和采集。</li>
</ul>
<p><font color=red size=4>必须：</font><br><strong>4 个黄金指标</strong>。监控系统的 4 个黄金指标。它们分别是：延迟、流量、错误和饱和度。如果我们只允许监控某个系统的4个指标，那么就应该监控这4个指标。</p>
<ul>
<li>延迟，也就是服务处理某个请求所需要的时间。延迟指标区分成功请求和失败请求很有必要。例如，某个由于数据库连接丢失或者其他后端问题造成的<code>HTTP500</code>错误可能延迟很低。在计算总体延迟时，如果将<code>HTTP500</code>回复的延迟也计算在内的话，可能会产生误导性的结果。但是，“慢” 错误要比 “快” 错误更糟！极少量的慢错误请求就可能导致系统吞吐能力的大幅降低。因此，监控错误回复的延迟是很重要的。</li>
<li>流量，是系统负载的度量方式。通常我们会使用某个高层次的指标来度量，比如IOPS、每秒交易量等。不同的业务系统的流量指标有较大差别。</li>
<li>错误，也就是请求失败的数量。请求失败的表现很多样。<ul>
<li>最简单的当然是显式失败，例如 <code>HTTP500</code>状态码。</li>
<li>还有的请求可能是隐式失败，例如<code>HTTP200</code>，但回复内容中提示出现了错误。这种尽可能由程序去修正</li>
<li>还有一种是策略原因导致的失败。例如，如果我们要求回复在1s内发出，任何超过1s的请求就都认为是失败请求。</li>
</ul>
</li>
<li>饱和度（Saturation），它度量的是服务容量有多 “满”。通常是系统中目前最为受限的某种资源的某个具体指标的度量。</li>
</ul>
<p><font color=green size=4>可选：</font><br><strong>时间序列数据库</strong>。时间序列数据库主要用于指处理带时间标签（按照时间的顺序变化，即时间序列化）的数据，带时间标签的数据也称为时间序列数据。时序数据库主要用来支撑Metrics的度量。它是以事件发生时间以及当前数值的角度来记录的监控信息，是可以聚合运算的，用于查看一些指标数据和指标趋势。<br>Metrics一般有5种基本的度量类型：</p>
<ul>
<li>Gauges（计量器）:它可以表示一个既可以增加, 又可以减少的度量指标值。它最简单和最基本的Metrics类型，只有一个简单的返回值，通常用来记录一些对象或者事物的瞬时值。计量器的典型使用场景包括：<ul>
<li>温度</li>
<li>内存使用量</li>
</ul>
</li>
<li>Counters（计数器）：它是一种累计型的度量指标，数值只能单调递增。计数器的典型使用场景包括：<ul>
<li>服务请求数</li>
<li>任务完成数</li>
<li>错误出现次数</li>
</ul>
</li>
<li>Histograms（直方图）：它可以用来度量流数据中value的分布情况，Histrogram可以计算最大/小值、平均值，方差，分位数（如中位数，或者95th分位数），如75%,90%,98%,99%的数据在哪个范围内。最大的特点是提供了多种多样的数据统计方式。直方图的典型使用场景包括：<ul>
<li>流量最大值</li>
<li>流量最小值</li>
<li>流量平均值</li>
<li>流量中位值</li>
</ul>
</li>
<li>Meters（TPS计算器）：它是一种只能自增的计数器，通常用来度量一系列事件发生的比率。他提供了平均速率，以及指数平滑平均速率，以及采样后的1分钟，5分钟，15分钟速率。TPS计数器的典型使用场景包括：<ul>
<li>平均每秒请求数</li>
<li>最近1分钟平均每秒请求数</li>
<li>最近5分钟平均每秒请求数</li>
<li>最近15分钟平均每秒请求数</li>
</ul>
</li>
<li>Timers（计时器）：Histogram跟Meter的一个组合，另外还提供了对于某段代码执行的耗时的统计及计算功能。计时器的典型使用场景包括：<ul>
<li>请求时延</li>
<li>磁盘读时延</li>
</ul>
</li>
</ul>
<p><font color=green size=4>可选：</font><br><strong>调用链监控</strong>。调用关系复杂的系统最好都上调用链监控。调用链监控一般需要收集应用层全量的数据进行分析，要分析的内容包括：调用量、响应时长、错误量等；面向的系统包括：应用、中间件、缓存、数据库、存储等；同时也支持对JVM 等的监控。我们调过pinpoint以无侵入式的方式对java应用进行采样监控。生成以下内容：</p>
<ul>
<li>调用链条。通过调用链条可以发现性能瓶颈，优化系统调用<br><img src="media/15839090412890/15863134544128.png" alt=""></li>
</ul>
<p><img src="media/15839090412890/15863129115169.jpg" alt=""></p>
<ul>
<li>服务依赖关系</li>
</ul>
<p><img src="media/15839090412890/15863134353566.png" alt=""></p>
<ul>
<li><p>服务调用的metrics<br><img src="media/15839090412890/15863112164938.jpg" alt=""></p>
<ul>
<li>服务的 TOP N 视图。一般来说，这个排名会有三种排名的方法：a）按调用量排名，b) 按请求最耗时排名，c）按热点排名（一个时间段内的请求次数的响应时间和）。<br><img src="media/15839090412890/15863134841492.png" alt=""></li>
<li>数据库操作关联。拿到JDBC执行数据库操作的执行时间。<br><img src="media/15839090412890/15863136054537.png" alt=""></li>
</ul>
</li>
<li><p>关联服务所在主机的系统监控<br><img src="media/15839090412890/15863131501883.png" alt=""></p>
</li>
</ul>
<h3 id="监控的要点"><a href="#监控的要点" class="headerlink" title="监控的要点"></a>监控的要点</h3><p>监控系统需要跟随不断演变的软件一起变化。软件的全局或某个局部发生重构，负载特性和性能目标就会变化。某个不常见的、自动化比较困难的报警，很可能随着用户增长很快变成一个经常触发、需要一个临时的脚本来应对的问题。添加监控看起来像是一个很繁琐的事务工作，但实际上它非常依赖你的架构能力。一个很牛的监控 SRE，他要干的绝对不是不停地添加新的监控项以 “完善某个业务的监控”。少就是指数级的多！</p>
<p><font color=red size=4>必须：</font><br><strong>监控企业的核心业务指标</strong>。监控企业的核心业务指标，能够以最快的速度反应系统是否稳定。</p>
<p><font color=red size=4>必须：</font><br><strong>分析长期趋势</strong>。例如每日活跃用户的数量，以及数量增长的速度。</p>
<p><font color=red size=4>必须：</font><br><strong>跨时间范围的比较</strong>，或者是观察 AB 测试组之间的区别。例如，增加新节点后，memcache 的缓存命中率是否增加？网站是否比上周速度要慢？使用 A 方案和 B 方案哪个更有助于用户的活跃？</p>
<p><font color=red size=4>必须：</font><br><strong>关联分析</strong>。例如，我们网站的请求延迟刚刚大幅增加了，有没有其他的现象同时发生？我们要能看到这些时点上的关联指标。</p>
<p><font color=red size=4>必须：</font><br><strong>采样</strong>。很多监控，比如链路监控和app的监控如果全开的话，对系统或者客户有较大的性能影响，网络和存储的压力也很大，所以往往会采用采样的策略。采样比要根据各系统实际情况进行调整，并可以在系统忙时降低采样比。</p>
<h3 id="告警"><a href="#告警" class="headerlink" title="告警"></a>告警</h3><p><font color=red size=4>必须：</font><br><strong>告警规则</strong>。为了有效的对系统异常提出告警，告警需要支撑以下规则和功能<br>    - 时间段内超过一定值<br>    <img src="media/15839090412890/15863957177933.jpg" alt="-w1231"><br>    - 数值波动<br>    <img src="media/15839090412890/15863957749480.jpg" alt="-w1183"><br>    - 逻辑运算，<code>以下条件全满足</code>及“以下条件任一”<br>    - 集群负载告警<br>        - 负载不均衡，或者有的负载为0<br>    - 与之前时间段相比较：<br>        - 5分钟前，1天前，1周前<br>    - 时间段内，持续状态<br>    <img src="media/15839090412890/15863963138490.jpg" alt="-w988"><br>    - 趋势预测<br>    <img src="media/15839090412890/15863370750647.jpg" alt="-w660"><br>    - 告警分级，比如info，warn<br>    - 告警通知机制<br>        - 根据级别，根据相应的工具通知责任团队<br>    - 告警去重<br>    - 告警屏蔽，在一定时间内（按告警配置）不重复告警，及可以在手动处理期间手工屏蔽告警</p>
<h2 id="第四部分：前端及易用性要求"><a href="#第四部分：前端及易用性要求" class="headerlink" title="第四部分：前端及易用性要求"></a>第四部分：前端及易用性要求</h2><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><ul>
<li>尽量避免横向滚动条，避免嵌套页面使用滚动条，不同时使用纵向和横向滚筒条。</li>
<li>应能识别并充分利用用户屏幕面积展现有效信息。</li>
<li>取消、提交的排列顺序应符合常规，有风险或可能导致用户重新录入大量数据的操作不应被缺省选中。</li>
</ul>
<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><ul>
<li>长时间操作应有明确信息提示用户正在处理中，并防止用户重复提交。</li>
<li>90%的操作应在一秒内完成响应，需要超过30秒的事务应后台处理，完成后通知用户。</li>
<li>非必须处理的提示性信息不要遮盖主页面、增加用户点击。</li>
</ul>
<h3 id="用户环境"><a href="#用户环境" class="headerlink" title="用户环境"></a>用户环境</h3><ul>
<li>避免苛刻的运行环境硬件要求或复杂的用户端设置。</li>
<li>尽量不要使用需要用到flash的组件。避免flash带来的用户体验问题<br>针对IE、Chrome等不能绿色安装、用户难以控制版本的浏览器，可提出最低版本要求但不应限制最高版本。</li>
<li>插件安装和环境变量设置应提供自动设置工具。</li>
<li>硬件要求、网络要求、环境变量设置等应有自检功能。</li>
</ul>
<h3 id="页面开发要求"><a href="#页面开发要求" class="headerlink" title="页面开发要求"></a>页面开发要求</h3><ol>
<li>尽可能的减少 HTTP 的请求数 （Make Fewer HTTP Requests ）。合并js、css等</li>
<li>添加Expire/Cache-Control 头：Add an Expires Header</li>
<li>启用Gzip压缩：Gzip Components</li>
<li>将css放在页面最上面 （ Put Stylesheets at the Top）</li>
<li>将script放在页面最下面 （Put Scripts at the Bottom ）</li>
<li>避免在CSS中使用Expressions （Avoid CSS Expressions ）</li>
<li>把javascript和css都放到外部文件中 （Make JavaScript and CSS External ）</li>
<li>减少DNS查询 (Reduce DNS Lookups)</li>
<li>压缩 JavaScript 和 CSS (Minify JavaScript )</li>
<li>避免重定向 (Avoid Redirects )</li>
<li>移除重复的脚本 (Remove Duplicate Scripts )</li>
<li>配置实体标签（ETags） (Configure ETags )</li>
<li>使 AJAX 缓存 (Make Ajax Cacheable )</li>
<li>使用CDN（内容分发网络）: Use a Content Delivery Network。这个我们很可能用不上，所以调整到最后。</li>
</ol>
<h2 id="第五部分：容器"><a href="#第五部分：容器" class="headerlink" title="第五部分：容器"></a>第五部分：容器</h2><p>应用开发应当满足以下要求以支撑容器化开发与部署。</p>
<h3 id="代码管理"><a href="#代码管理" class="headerlink" title="代码管理"></a>代码管理</h3><p>所有软件使用统一的局方代码库进行管理，并以此为基础进行打包、部署。</p>
<h3 id="显式依赖"><a href="#显式依赖" class="headerlink" title="显式依赖"></a>显式依赖</h3><ul>
<li>显式声明依赖关系：不允许在应用中隐式使用依赖的类库、依赖的某些系统工具，必须显式申明；同时简化环境配置，保持运行环境一致性。</li>
<li>依赖包定时清理：开发过程中定时清理不必要的依赖，优化镜像文件大小，避免镜像大小随着版本迭代不断扩大，单个镜像文件不得大于1GB。</li>
</ul>
<h3 id="构建、发布和运行"><a href="#构建、发布和运行" class="headerlink" title="构建、发布和运行"></a>构建、发布和运行</h3><ul>
<li>严格分离构建、发布和运行：通过DevOps流程串起交付流程，不允许在运行中修改代码或者对应用进行打补丁。</li>
<li>在构建时，须使用平台方提供的镜像仓库和基础镜像（带工具包的centos、jdk、nginx、tomcat、filebeat及其他生产需要的基础镜像等）。根据自身需求在基础镜像的基础上进行构建与部署。构建与发布时，须符合安全规范。</li>
</ul>
<h3 id="应用无状态"><a href="#应用无状态" class="headerlink" title="应用无状态"></a>应用无状态</h3><p>以一个或多个无状态进程运行应用：应用无状态且无共享，任何需要持久化使用的数据都要存储在后端服务中，如数据库、缓存系统等。应用实例之间的数据共享也要通过数据库和缓存系统等外部服务进行，以免为应用的横向扩展带来障碍。</p>
<h3 id="端口绑定"><a href="#端口绑定" class="headerlink" title="端口绑定"></a>端口绑定</h3><ul>
<li>通过端口绑定提供服务：应用直接与端口绑定，而不依赖应用服务器，避免一个应用服务器中运行多个应用。端口绑定由平台自动完成，自动实现内、外部端口映射，端口发生变化，访问URL保持不变，实现动态注册。</li>
<li>应用应该完全自我包含，而不是依赖于外部的应用服务器，或者使用嵌入式应用服务器，避免将多个应用放置于同一个应用服务器上运行。</li>
<li>进行端口规划：进行开发时，需要预先规划应用的端口需求，以及对网关配置的管理方式。</li>
</ul>
<h3 id="横向可扩容"><a href="#横向可扩容" class="headerlink" title="横向可扩容"></a>横向可扩容</h3><p>通过进程模型进行扩展：通过快速复制、启动多个相同进程，支持分布式，横向容器扩容，提高系统并发处理能力。</p>
<h3 id="快速启动和优雅终止"><a href="#快速启动和优雅终止" class="headerlink" title="快速启动和优雅终止"></a>快速启动和优雅终止</h3><ul>
<li>快速启动：应用设计快速启动，实现更敏捷的发布与扩展；应用设计应该能够应对意外的、不优雅的终止，可以瞬间（理想情况下是数秒或者更短）启动和停止，提高系统健壮性（不可靠设计）。</li>
<li>优雅终止：应用应当按照标准要求提供API以支撑缩荣场景下的优雅终止。</li>
</ul>
<h3 id="集中的应用配置中心"><a href="#集中的应用配置中心" class="headerlink" title="集中的应用配置中心"></a>集中的应用配置中心</h3><ul>
<li>需要引入分布式配置管理能力，建设统一的配置中心，将代码与配置分离。</li>
<li>配置指与部署环境有关的配置，例如：.数据库、消息代理、缓存系统等后端服务的连接配置和位置信息，如URL、用户名、密码等；.第三方服务的证书；.每份部署独有的配置，例如：域名、连接数、JVM参数等。应用配置中心主要面向非业务相关的技术参数配置，不建议对业务类信息（例如：业务规则配置、流程配置、业务参数配置、产销售品配置等）在此配置。</li>
</ul>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><ul>
<li>应用程序需要将日志以事件流的方式输出到标准输出STDOUT和标准错误输出STDERR，由运行环境捕获这些事件流，并（或直接）转发到专门的日志处理服务进行处理。</li>
<li>应用程序在发布前，必须关闭其Info和Debug级别日志的打印。</li>
</ul>
<h3 id="管理进程"><a href="#管理进程" class="headerlink" title="管理进程"></a>管理进程</h3><p>管理进程：管理和维护应用的任务应该与运行的应用使用相同环境、配置，后台管理代码应该随应用程序一同发布，避免发生不同步问题。避免直接通过ssh接入方式执行管理任务，通过云上提供的能力完成管理任务，比如配置中心完成配置修改、分布式调度框架完成job、迁移工具完成数据迁移。</p>
<h3 id="验证测试"><a href="#验证测试" class="headerlink" title="验证测试"></a>验证测试</h3><p>部署发布到生产环境的应用，都必须在测试环境验证过之后才允许发布，有以下问题的应用不允许发布：</p>
<ul>
<li>内存（&gt;95%）、CPU（&gt;100%）负载持续异常（&gt;10min）的容器；</li>
<li>句柄数异常高（数万甚至十几万的）的容器；</li>
<li>持续输出大量业务日志（如java异常日志、业务受理信息、连接异常日志、业务报错日志等）的应用；</li>
<li>存在线程死锁等异常的应用存在内存泄漏、内存溢出等的应用；</li>
<li>流量异常（大于过去平均值3倍以上）的应用；</li>
</ul>
<h3 id="自动部署"><a href="#自动部署" class="headerlink" title="自动部署"></a>自动部署</h3><p>需要基于Jenkins等工具，通过部署流水线的方式实现一键式，自动化的部署。部署时，应根据自己的实际需要，配置服务的约束策略和启动优先级。</p>
<h3 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h3><p>IT系统持续交付过程需要考虑灰度发布，以最大程度降低快速迭代过程中对于业务连续性影响的风险。</p>
<h3 id="快速回退"><a href="#快速回退" class="headerlink" title="快速回退"></a>快速回退</h3><p>支持发布过程失败或者发布后验证失败后，灰度环境或正式环境可以快速回退到上一可用的应用版本。数据库的变更不允许删除字段，保持对不同应用版本的兼容性。</p>
<h2 id="第六部分：集团PaaS组件"><a href="#第六部分：集团PaaS组件" class="headerlink" title="第六部分：集团PaaS组件"></a>第六部分：集团PaaS组件</h2><p>PaaS平台组件以《中国电信PaaS组件清单（试行稿）》为准，严格按照清单选型组件，集团组件的开发约束规范以集团组件开发规范文档为准，部分组件示例要求如下：</p>
<h3 id="分布式消息"><a href="#分布式消息" class="headerlink" title="分布式消息"></a>分布式消息</h3><h4 id="消息队列场景建议"><a href="#消息队列场景建议" class="headerlink" title="消息队列场景建议"></a>消息队列场景建议</h4><ul>
<li>kafka主要特点是基于Pull的模式处理消息消费，追求高吞吐量，用于日志收集和传输，适合产生大量数据的互联网服务的数据收集业务。如有日志采集功能，首选kafka；</li>
<li>CTG-MQ适用于互联网领域，对于可靠性要求很高的场景，尤其适用于业务削峰，后端可能无法及时处理的情况。如业务有上述并发场景，建议使用CTG-MQ；</li>
</ul>
<h4 id="集团消息组件Ctg-MQ"><a href="#集团消息组件Ctg-MQ" class="headerlink" title="集团消息组件Ctg-MQ"></a>集团消息组件Ctg-MQ</h4><ul>
<li>topic、queue的规划:同一消费组消费者实例数的上限=队列数，需要分布式消费的情况，需考虑队列数的设置;</li>
<li>C++客户端只提供Pull Consumer，Java客户端必须使用Push Consumer，推荐使用Java客户端Push方式；</li>
<li>生产者客户端和消费者客户端依赖版本需和生产环境的ctgmq版本一致；</li>
<li>消息队列中消息体大小不能超过20K，主题队列数每个节点设置为5-10；</li>
<li>在业务场景允许的情况下，优先选择无序消息，或者在业务能变通的情况下，将有序消息转化为无序消息；</li>
<li>消费幂等:从业务层面做去重处理，业务逻辑实现消费幂等，即多次处理同一消息；</li>
<li>生产者客户端和消费者客户端连接生产环境中ctgmq地址，必须配置ServerName多地址；</li>
<li>使用ctgmq的应用程序开发严格参照附件《中国电信IT云平台-CTGMQ-API说明文档(Java)》和《中国电信IT云平台-CTGMQ-设计与开发规范》；</li>
</ul>
<h4 id="开源消息组件kafka"><a href="#开源消息组件kafka" class="headerlink" title="开源消息组件kafka"></a>开源消息组件kafka</h4><ul>
<li>版本选择使用kafka_2.11-1.1.0以上稳定运行的kafka版本；</li>
<li>应用开发只允许使用生产者客户端API，消费者客户端API以及流处理API来在kafka集群生产环境中生产和消费消息；</li>
<li>禁止使用AdminClient API支持管理操作和检查生产环境中的主题、代理、ACL和其他Kafka对象；</li>
<li>生产者客户端和消费者客户端依赖版本需和生产环境的kafka版本一致；</li>
<li>生产者客户端需采用异步生产方式，消费者客户端需采用手动提交偏移量的方式；</li>
<li>生产者客户端和消费者客户端连接生产环境中kafka地址，必须配置多地址集群模式；</li>
<li>禁止其他一切可能造成集群性能压力或故障的客户端程序使用生产环境中的kafka集群；</li>
<li>消息队列中消息体大小不能超过10K，主题分区数不超过80，每个节点分区数总和不超过1000；</li>
<li>生产者和消费者客户端配置非必要修改配置保持默认配置；如有特殊情况，根据业务场景修改相应配置；</li>
</ul>
<h3 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h3><h4 id="缓存场景及版本"><a href="#缓存场景及版本" class="headerlink" title="缓存场景及版本"></a>缓存场景及版本</h4><ul>
<li>主要应用场景为热点数据的缓存、限时间业务的运用等，数据量非常大和冷数据的存储不要使用分布式缓存。</li>
<li>开源缓存组件Redis 5.0及以上版本；集团缓存组件Ctg-Cache 2.4.1P1及以上版本。</li>
</ul>
<h4 id="集团缓存组件Ctg-Cache"><a href="#集团缓存组件Ctg-Cache" class="headerlink" title="集团缓存组件Ctg-Cache"></a>集团缓存组件Ctg-Cache</h4><ul>
<li>应用侧访问ctgcache必须做失败重连机制；</li>
<li>ctg-cache的单个连接只能单线程调用，不可多线程复用；</li>
<li>获取连接后及时归还连接，使用过程中发生异常catch后要归还连接；</li>
<li>须对非参数类数据设置数据生存时间，且在满足业务需求条件下尽量缩短生存时间。如业务场景确实不允许对数据设置过期时间，则须配置自动清理策略，及时清理缓存数据；</li>
<li>禁止使用keys、monitor、flushall、flushdb等危险命令；</li>
<li>禁止批量操作Hash、Set、list等集合数据结构，如hgetall、lrange、smembers、zrange、sinter等命令，如有遍历需求可使用hscan、sscan、zscan等命令代替；</li>
<li>使用ctg-cache，要求单条key-value存取报文不超过32K；hash、list、set、zset元素个数不超过10000；</li>
<li>不可使用事务，因为事务功能较弱；</li>
<li>业务应用须按照集团指导规范文件&quot;中国电信IT云平台—分布式缓存开发指导规约&quot;中&quot;开发示例&quot;进行缓存调用的相关开发；</li>
<li>最佳实践、设计案例、使用限制、命名规范、存储约束等请参照&quot;中国电信IT云平台—分布式缓存开发指导规约&quot;。</li>
</ul>
<h4 id="开源缓存组件Redis"><a href="#开源缓存组件Redis" class="headerlink" title="开源缓存组件Redis"></a>开源缓存组件Redis</h4><ul>
<li>业务侧须使用连接池方式连接redis集群；</li>
<li>须对非参数类数据设置数据生存时间，且在满足业务需求条件下尽量缩短生存时间。如业务场景确实不允许对数据设置过期时间，则须配置自动清理策略，及时清理缓存数据；</li>
<li>禁止使用keys、monitor、flushall、flushdb等危险命令；</li>
<li>禁止全量操作Hash、Set、list等集合结构，如hgetall、lrange、smembers、zrange、sinter等命令，如有遍历需求可使用hscan、sscan、zscan等命令代替；</li>
<li>禁止使用del命令暴力删除bigkey（key-value &gt; 5g）；</li>
<li>禁止bigkey：string类型控制在50KB以内，hash、list、set、zset元素个数不要超100000；</li>
<li>名称不包含空格、换行、单双引号以及其它转义字符；</li>
<li>不可使用redis事务功能，redis的事务功能较弱；</li>
<li>一般场景缓存不开启持久化。</li>
</ul>
<h3 id="服务框架"><a href="#服务框架" class="headerlink" title="服务框架"></a>服务框架</h3><p>目前服务框架为开源工具dubbo。</p>
<h4 id="模块与分包"><a href="#模块与分包" class="headerlink" title="模块与分包"></a>模块与分包</h4><ul>
<li>基于复用度分包，一起使用的放在同一包下，将接口和基类分成独立模块，大的实现也使用独立模块。</li>
<li>所有服务接口、服务模型、服务异常等接口都放在模块的根包下，基类放在 support 子包下，不同实现用放在以扩展点名字命名的子包下。</li>
<li>保持子包依赖父包，而不要反向。</li>
</ul>
<h4 id="粒度与设计原则"><a href="#粒度与设计原则" class="headerlink" title="粒度与设计原则"></a>粒度与设计原则</h4><ul>
<li>禁止使用分布式事务支持。</li>
<li>服务接口必须以业务场景为单位划分，并对相近业务做抽象，防止接口数量爆炸。</li>
<li>禁止使用过于抽象的通用接口，如：Map query(Map)，这样的接口没有明确语义，会给后期维护带来不便。</li>
</ul>
<h4 id="接口版本"><a href="#接口版本" class="headerlink" title="接口版本"></a>接口版本</h4><p>每个接口都需要定义版本号。</p>
<h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><ul>
<li>服务参数及返回值必须使用 POJO 对象，即通过 setter, getter 方法表示属性的对象。</li>
<li>服务参数及返回值都必须是传值调用，而不能是传引用调用。</li>
</ul>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><ul>
<li>必须使用异常汇报错误，而不是返回错误码，异常信息能携带更多信息，并且语义更友好。</li>
<li>服务提供方禁止将 DAO 或 SQL 等异常抛给消费方，应在服务实现中对消费方不关心的异常进行包装，否则可能出现消费方无法反序列化相应异常。</li>
</ul>
<h4 id="Provider-端配置"><a href="#Provider-端配置" class="headerlink" title="Provider 端配置"></a>Provider 端配置</h4><h5 id="需要在-Provider-端配置的-Consumer-端属性有："><a href="#需要在-Provider-端配置的-Consumer-端属性有：" class="headerlink" title="需要在 Provider 端配置的 Consumer 端属性有："></a>需要在 Provider 端配置的 Consumer 端属性有：</h5><ul>
<li>timeout：方法调用的超时时间。</li>
<li>retries：失败重试次数，缺省是 2 。</li>
<li>loadbalance：负载均衡算法，缺省是随机 random。</li>
<li>actives：消费者端的最大并发调用限制。</li>
</ul>
<h5 id="需要在-Provider-端配置的-Provider-端属性有："><a href="#需要在-Provider-端配置的-Provider-端属性有：" class="headerlink" title="需要在 Provider 端配置的 Provider 端属性有："></a>需要在 Provider 端配置的 Provider 端属性有：</h5><ul>
<li>threads：服务线程池大小</li>
<li>executes：一个服务提供者并行执行请求上限</li>
</ul>
<h4 id="配置管理信息"><a href="#配置管理信息" class="headerlink" title="配置管理信息"></a>配置管理信息</h4><ul>
<li>必须至少配置两个人以便备份；</li>
<li>在应用层面配置负责人、组织信息：<br><code>&lt;dubbo:application owner=&quot;ding.lid,william.liangf&quot; organization=&quot;intl&quot;/&gt;</code></li>
<li>在服务层面（服务端）配置负责人：<br><code>&lt;dubbo:service owner=&quot;ding.lid,william.liangf&quot;/&gt;</code></li>
<li>在服务层面（消费端）配置负责人：<br><code>&lt;dubbo:reference owner=&quot;ding.lid,william.liangf&quot;/&gt;</code></li>
<li>若没有配置服务层面的负责人，则默认使用 dubbo:application 设置的负责人。</li>
</ul>
<h4 id="监控配置"><a href="#监控配置" class="headerlink" title="监控配置"></a>监控配置</h4><ul>
<li>使用固定端口暴露服务，而不要使用随机端口。这样在注册中心推送有延迟的情况下，消费者通过缓存列表也能调用到原地址，保证调用成功。</li>
<li>使用 Dubbo Admin 监控注册中心上的服务提供方。使用 Dubbo Admin 监控服务在注册中心上的状态，确保注册中心上有该服务的存在。</li>
</ul>
<h3 id="分布式索引（ElasticSearch"><a href="#分布式索引（ElasticSearch" class="headerlink" title="分布式索引（ElasticSearch)"></a>分布式索引（ElasticSearch)</h3><h4 id="版本和应用场景"><a href="#版本和应用场景" class="headerlink" title="版本和应用场景"></a>版本和应用场景</h4><ul>
<li>提供ElasticSearch 7以上版本，配套提供中文化的kibana。</li>
<li>主要应用场景为日志分析，涉及大量计算或者聚合查询的应用不要使用elasticsearch。</li>
</ul>
<h4 id="设计规则"><a href="#设计规则" class="headerlink" title="设计规则"></a>设计规则</h4><ul>
<li>所有新建模板和索引必须遵循命名规范。</li>
<li>索引命名：&lt;专业域&gt;-*-&lt;时间&gt;如paas-hostLog-2018.11.20（按日建索引）、crm-mid-order-2018.10（按月建索引）。</li>
<li>模板命名：需要与索引名对应，如template-paas-hostLog。</li>
<li>模板的配置需尽可能详细，至少包含优先级、索引名规则、分片数、副本数、translog、slowlog配置，明确字段类型，减少text类型使用，以降低集群压力，提高ES性能；</li>
<li>合理规划单索引分片数量，一个分片30GB左右，过多分片将增大集群管理压力，消耗资源，影响写入和查询性能；</li>
<li>上线前，应用需要提供索引数据量、存储周期、查询周期、写入峰值线程数；</li>
<li>7版本有默认type，为_doc，请不要规定type或使用多种type，官方说明8版本将彻底移除type。</li>
</ul>
<h4 id="数据链接写入规则"><a href="#数据链接写入规则" class="headerlink" title="数据链接写入规则"></a>数据链接写入规则</h4><ul>
<li>请使用短链接；</li>
<li>写入时，请使用bulk API进行批量写入，仅需配置所有master节点；</li>
<li>在模板中规定数据类型；</li>
<li>避免大文件，最大限制是100MB；</li>
<li>禁止稀疏。避免将不相关的数据放在同一个索引中。</li>
</ul>
<h4 id="数据查询规范"><a href="#数据查询规范" class="headerlink" title="数据查询规范"></a>数据查询规范</h4><ul>
<li>返回结果少于100万条</li>
<li>聚合不得超过10层</li>
<li>禁用查询中的_all</li>
<li>优化query，查询的query返回必要字段，不用的字段不返回，减小返回值大小</li>
<li>禁止对分词字段（text）进行聚合查询</li>
<li>避免通配符（*）使用</li>
<li>禁用查询中的_all；</li>
<li>禁止对分词字段（text）进行聚合查询；</li>
<li>组件运维人员会对slowlog进行采集分析，对应用提出优化建议。</li>
</ul>
<h4 id="ES写入规范"><a href="#ES写入规范" class="headerlink" title="ES写入规范"></a>ES写入规范</h4><ul>
<li>写入数据时，只需要配置master节点的9200类端口即可，不需要配置其他节点。明确使用的用户、密码和写入的索引</li>
<li>Logstash配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts &#x3D;&gt; [&quot;XXX.XXX.XXX.XXX:9200&quot;,&quot;XXX.XXX.XXX.XXX:9200&quot;,&quot;XXX.XXX.XXX.XXX:9200&quot;;]</span><br><span class="line">    index &#x3D;&gt; &quot;test-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">    user &#x3D;&gt; &quot;paasAdmin&quot;</span><br><span class="line">    password &#x3D;&gt; &quot;password&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ES更多建议"><a href="#ES更多建议" class="headerlink" title="ES更多建议"></a>ES更多建议</h4><h5 id="Bulk最佳大小测试："><a href="#Bulk最佳大小测试：" class="headerlink" title="Bulk最佳大小测试："></a>Bulk最佳大小测试：</h5><ul>
<li>确认bulk requests（批量请求）的最佳大小，要在单个节点上使用单个分片进行基准测试来获取。首先尝试一次性索引 100 个 documents（文档），然后200个，然后400个；在每个基准测试中，下一次索引的 documents（文档）数是上一次的两倍。当索引速率达到最高时，就可以确认每次 bulk requests（ 批量请求）的最佳 documents（文档）数大小了。</li>
<li>在正常情况下，最好是发生的错误越少越好而不是索引的documents（文档）越多越好。当心，很多客户端同时发送数据产生非常大的 bulk requests（ 批量请求）使集群处在内存压力下；即使看起来较大的请求会更好，还是建议每个请求不要超出几十兆字节。</li>
</ul>
<h5 id="官方客户端："><a href="#官方客户端：" class="headerlink" title="官方客户端："></a>官方客户端：</h5><ul>
<li>常见的ES jest不支持ES7以上版本，请使用官方client。</li>
</ul>
<p>ES提供多种语言的开发客户端，详见：</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/client/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/client/index.html</a></p>
<ul>
<li>java客户端建议选择java api</li>
</ul>
<h2 id="第七部分：数据库规范"><a href="#第七部分：数据库规范" class="headerlink" title="第七部分：数据库规范"></a>第七部分：数据库规范</h2><p>按照集团要求，后续建议使用关系型数据库时建议选用mysql，相关要求如下。</p>
<h3 id="MYSQL数据库规范"><a href="#MYSQL数据库规范" class="headerlink" title="ＭＹＳＱＬ数据库规范"></a>ＭＹＳＱＬ数据库规范</h3><h4 id="选型规范"><a href="#选型规范" class="headerlink" title="选型规范"></a>选型规范</h4><p>MYSQL的使用分为单实例模式和分布式模式。分布式模式用于数据量比较大，需要进行分库分表的情况。</p>
<ol>
<li>主从，部署简单，方便维护，高可用需要人工或者其他第三方软件介入，切换后可能需要重做从库。</li>
<li>主主（M-M），它部署容易、方便维护，自动恢复高可用，双写容易冲突，数据一致性较弱，要注意延迟和数据的一致性，建议单节点写入主。</li>
<li>PXC，分布式协议，数据强一致性，并发效率略低，可用性好，性能损耗大（降低为1/3）、 大事务会卡住整个集群、需要用第三方发行版MySQL。</li>
<li>MHA传统高可用，各项指标介于M-M和PXC之间，性能无损失，适合读写分离架构，需要配合第三方脚本进行自动切换</li>
<li>TELEDB分布式数据库，独特的安全策略：白名单访问控制；数据库账户有效期等，支持线程池技术，配合udal实现分库分表，读写分离，集团主推，对比原生mysql有一定限制。</li>
</ol>
<h4 id="安装部署规范"><a href="#安装部署规范" class="headerlink" title="安装部署规范"></a>安装部署规范</h4><ol>
<li>操作系统使用linux 7。</li>
<li>Mysql版本选用MySQL社区版5.7，最好是5.7最新版本。</li>
<li>软件安装在mysql用户，mysql组，并安装在单独/mysql目录。</li>
<li>挂载单独数据目录/data,合理规划数据，日志存放。</li>
<li>数据库默认字符集 character-set-server=utf8mb4。</li>
<li>事务隔离级别，mysql默认可重复读级别（此级别下可能参数很多间隙锁，影响性能），电信默认为 READ-COMMITTED。</li>
<li>不使用默认端口3306。</li>
<li>开启gtid模式，统一使用增强半同步复制。</li>
<li>使用独立表空间。</li>
<li>开启binlog,并使用row模式。</li>
<li>主主架构，使用自增序列会存在冲突的情况，需要设置auto_increment_offset、auto_increment_increment参数并写入my.cnf。</li>
<li>开启SSl加密。</li>
<li>单实例大小不建议超过1T。</li>
</ol>
<h4 id="MYSQL维护规范："><a href="#MYSQL维护规范：" class="headerlink" title="MYSQL维护规范："></a>MYSQL维护规范：</h4><ol>
<li>批量操作拆分，要分批多次进行操作，大批量操作可能会造成严重的主从延迟。</li>
<li>MySQL 在 5.6 之后引入了在线修改表结构，但是在某些情况下还是会锁表，所以一般都采用 PT 工具( Percona Toolkit)修改表结构。可以避免大表修改产生的主从延迟，并避免在对表字段进行修改时进行锁表。</li>
<li>如果有自增列，truncate语句会把自增列的基数重置为0，有些场景用自增列作为业务上的id需要十分重视。</li>
<li>不要在MySQL数据库中存放业务逻辑：数据库是有状态的服务，变更复杂而且速度慢，如果把业务逻辑放到数据库中，将会限制业务的快速发展。建议把业务逻辑提前，放到前端或中间逻辑层，而把数据库作为存储层，实现逻辑与存储的分离。</li>
<li>定期进行表分析。</li>
<li>定期进行碎片整理。</li>
</ol>
<h4 id="用户规范。"><a href="#用户规范。" class="headerlink" title="用户规范。"></a>用户规范。</h4><ol>
<li>分清用户职责，用户分为：生产，历史，维护，接口，备份等，杜绝一用户多职责</li>
<li>锁定数据库默认用户</li>
<li>及时修改默认密码，并定期修改密码</li>
<li>只授予能满足需要的最小权限，防止用户越权。如用户只是需要查询，那就只赋予select权限，不要给用户赋予update、insert或者delete权限。</li>
<li>创建用户的时候限制用户的登录主机，一般是限制成指定lP或者内网IP段。</li>
<li>初始化数据库的时候删除没有密码的用户。安装完数据库的时候会自动创建一些用户，这些用户默认没有密码。</li>
<li>为每个用户设置满足密码复杂度的密码。</li>
<li>定期清理不需要的用户，回收权限或者删除用户。</li>
</ol>
<h4 id="备份规范："><a href="#备份规范：" class="headerlink" title="备份规范："></a>备份规范：</h4><ol>
<li>全库备份选用物理备份，单表，单库备份使用逻辑备份。</li>
<li>物理备份推荐xtracbackup,逻辑备份推荐使用mysqldump。</li>
<li>备份期间禁止长时间持有全局锁。</li>
<li>所有备份文件存放在异机。</li>
<li>备份应避开业务高峰期。</li>
<li>定期在异机实施备份恢复测试。</li>
</ol>
<h4 id="分库分表规范："><a href="#分库分表规范：" class="headerlink" title="分库分表规范："></a>分库分表规范：</h4><ol>
<li>分库分表分库虽然能解决大表对数据库系统的压力，但它并不是万能的，也有一些不利之处，因此首要问题是，分不分库，分哪些库，什么规则分，分多少分片。</li>
<li>分片数量尽量少，分片尽量均匀分布在多个DataHost 上，因为一个查询SQL 跨分片越多，则总体性能越差。分片数量提前规划，尽量避免增加分片数量。</li>
<li>800万以内的表，不建议分片，通过合适的索引，读写分离等方式，可以很好的解决性能问题。</li>
<li>不到800 万但跟大表（超800 万的表）有关联查询的表也要拆分，在此称为大表关联表。大表关联表如何拆：小于100 万的使用全局表；大于100 万小于800 万跟大表使用同样的拆分策略；无法跟大表使用相同规则的，可以考虑从java 代码上分步骤查询，不用关联查询，或者破例使用全局表。</li>
<li>破例的全局表：如item_sku 表250 万，跟大表关联了，又无法跟大表使用相同拆分策略，也做成了全局表。破例的全局表必须满足的条件：没有太激烈的并发update，如多线程同时update 同一条id=1 的记录。虽有多线程update，但不是操作同一行记录的不在此列。多线程update 全局表的同一行记录会死锁，批量insert 没问题。</li>
<li>拆分字段只能是一个字段，如果想按照两个字段拆分，必须新建一个冗余字段，冗余字段的值使用两个字段的值拼接而成（如大区+年月拼成zone_yyyymm 字段）。</li>
<li>分片规则需要慎重选择，分片规则的选择，需要考虑数据的增长模式，数据的访问模式，分片关联性问题，分片扩容问题以及数据热点问题。一般来说，分片的选择是取决于最频繁的查询SQL 的条件。</li>
</ol>
<h4 id="TELEDB集团规范"><a href="#TELEDB集团规范" class="headerlink" title="TELEDB集团规范"></a>TELEDB集团规范</h4><ol>
<li>首先明确规定：禁用存储过程，函数，触发器，视图；所有逻辑业务上实现！</li>
<li>统一使用InnoDB存储引擎，系统已指定默认存储引擎为innodb。</li>
<li>创建表时要明确定义主键，推荐为int/bigint类型的字段作为主键，如果是自增ID则更为完美。</li>
<li>业务表设计时必须包含日期字段，createitme和lastupdatetime。</li>
<li>每个数据表中字段数量尽可能少。当表的字段数较多时，建议将表分成两张表，一张作为条件查询表，一张作为详细内容表。</li>
<li>数据表记录数尽可能少，线上单表数据建议不超过1000万，可以通过分库、分表方式实现。</li>
<li>创建表时，所有表名、字段名都需要添加注释。</li>
<li>表字符集统一使用utf8mb4，核对规则为utf8mb4_bin，不允许其它字符编码。也不允许在字段里边自己定义字符集。</li>
<li>满足需求的情况下，字段类型越短越好（可以用int的则不能用bigint，能用tinyint的不能用int） 。</li>
<li>尽量不要使用default null，所有的字段尽可能都设定为not null并为其定义默认值。</li>
<li>需要多表 join的字段或直接比较的字段，数据类型保持绝对一致。</li>
<li>当字段的类型为枚举型或布尔型时，建议使用 tinyint类型。</li>
<li>一般情况下不允许使用TEXT、BLOG，确实需要则拆分。</li>
<li>同理，当varchar字段超过一定长度（256）时，建议拆分。</li>
<li>内容明确，不做变更的类型代码可用枚举类型。</li>
<li>不要修改聚集索引（主键）。</li>
<li>索引不是越多越好，尽量合并索引。</li>
<li>不要给选择性低的字段建单列索引。</li>
<li>不要使用外键约束。</li>
<li>字符类型字段尽量使用前缀索引。</li>
<li>合理使用复合索引，复合索引一般情况下比普通索引更加合适，有些索引可以修改成复合索引。</li>
<li>LIKE查询的索引问题，注意使用前缀索引。</li>
<li>首要原则：语句尽量简单，不在数据库做复杂运算，不用存储过程、函数。</li>
<li>select，insert一定要带上字段名，尽量少用select *。</li>
<li>优化LIMIT分页：不要用LIMIT start, offset，更高效方法可以找dba。</li>
<li>不要在where语句后的索引列做运算或表达式，会导致用不了索引禁用。</li>
<li>只用inner join或者left join；禁止用right join。表关联的on必须有索引，只关联需要表，只选择需要的列。</li>
<li>复杂查询拆分简单查询；尽量小批量小语句分段执行；一个sql不要超过1G的binlog。</li>
<li>大事务可以set auto_commit =0 关闭自动提交，但是拒绝滥用，会导致阻塞。</li>
</ol>
<h3 id="UDAL集团规范"><a href="#UDAL集团规范" class="headerlink" title="UDAL集团规范"></a>UDAL集团规范</h3><ol>
<li>暂不支持用户自定义数据类型、自定义函数。</li>
<li>暂不支持视图、存储过程、触发器、游标。</li>
<li>暂不支持 BEGIN…END、LOOP…END LOOP、REPEAT…UNTIL…END REPEAT、WHILE…DO…END WHILE 等复合语句。</li>
<li>暂不支类似 IF ，WHILE 等流程控制类语句。</li>
<li>不支持 SAVEPOINT 操作</li>
<li>不支持SQL里带schema操作</li>
<li>MySQL自增字段，使用全局序列替换数据库的自增序列</li>
<li>跨节点操作：prohibitCrossTransaction为true，如果不启动分布式事务（dt start），则不允许执行跨节点update/delete语句。prohibitCrossTransaction为false，允许执行跨节点update/delete语句，建议执行前开启分布式事务，保障跨节点操作的数据一致性</li>
<li>关联查询：关联表使用的分片算法一致，关联表数据拆分的节点必须相同，关联查询 SQL 上必须带有分片键字段的关联，和全局表做关联，要保证非全局表所在的节点有对应全局表即可</li>
<li>union约束：使用union关键字的sql，要求其中涉及的分片表的分片规则及配置参数一致，使用union all关键字的sql则无此要求。分片表不支持union/union all与聚合函数、limit、groupby、having、orderby等关键字联用。不支持分片表和全局表union</li>
<li>JDBC约束：不支持 rewriteBatchedStatements=true 参数设置(默认为 false)。不支持 useServerPrepStmts=true 参数设置(默认为 false)。</li>
</ol>
<h2 id="第八部分：公共组件的接入要求"><a href="#第八部分：公共组件的接入要求" class="headerlink" title="第八部分：公共组件的接入要求"></a>第八部分：公共组件的接入要求</h2><h3 id="端到端监控"><a href="#端到端监控" class="headerlink" title="端到端监控"></a>端到端监控</h3><p>端到端监控系统提供如下功能：</p>
<ul>
<li>监控指标数据和日志信息的采集和存储</li>
<li>面向各项目组的监控视图的定制和展现</li>
<li>告警策略的定义和执行</li>
<li>告警信息的发送</li>
<li>人工派单策略的定义和执行</li>
</ul>
<p>其他各系统通过端到端监控提供API或代理采集并上传监控指标数据和日志信息，在平台配置或插入告警策略、派单策略，其余功能不再重复建设。</p>
<h3 id="用户问题管理"><a href="#用户问题管理" class="headerlink" title="用户问题管理"></a>用户问题管理</h3><p>问题管理平台提供如下功能：</p>
<ul>
<li>接收用户问题的API和本地插件（截图、上下文数据获取等）</li>
<li>问题分类策略的定制和执行</li>
<li>进一步沟通问题的在线交互页面</li>
<li>匹配建议解决方案或相关知识点的API或可供集成的H5页面</li>
<li>派单策略、处理流程、处理时限的定制和执行</li>
<li>面向各项目组的问题处理情况的监控、跟踪、抽检等管理功能</li>
<li>问题处理进展情况跟踪页面和通知</li>
</ul>
<p>各业务系统在报错时需要遵守以下要求</p>
<ul>
<li>报错信息应能明确指示用户的下一步行动，不得提供虚假信息误导用户，有唯一编码以便用户报障或查阅操作说明。</li>
<li>应提供在线方式由最终用户直接提交问题，并根据业务需要保证处理时限。</li>
<li>集成问题管理平台的问题提交、跟踪、建议解决方案推送和在线沟通页面，在问题管理平台配置或插入问题分类、派单策略、处理流程和处理时限。</li>
</ul>
<h3 id="统一部署平台"><a href="#统一部署平台" class="headerlink" title="统一部署平台"></a>统一部署平台</h3><p>统一部署平台提供如下功能：</p>
<ul>
<li>各部署节点的镜像文件上传和版本管理</li>
<li>各部署节点运行环境配置（内存、CPU、网络带宽、延迟、最少最大节点数等）</li>
<li>各节点的网络流量分配策略，具体到版本，可在线调整</li>
<li>各节点的告警</li>
<li>运行容器平台，完成镜像文件到容器平台的部署，根据负载情况自动伸缩</li>
<li>向各项目组提供必要的监控数据和展现视图</li>
</ul>
<p>各项目组提供各部署模块所用的镜像文件、环境配置和流量策略等，不再申请和管理主机来运行生产环境。</p>
<h3 id="eop"><a href="#eop" class="headerlink" title="eop"></a>eop</h3><p>EOP提供如下功能：</p>
<ul>
<li>服务发现、注册</li>
<li>用户注册、授权、鉴权</li>
<li>流控（某用户到某服务）</li>
<li>流量加密和敏感信息过滤</li>
<li>日志和监控（吞吐量、时延、错误率）</li>
<li>业务逻辑无关的协议转换</li>
<li>遵循业界标准统一定义基本的错误代码，并提供错误代码的登记和查询功能</li>
</ul>
<p>各系统API开放、跨系统调用服务均应通过EOP，不再重复开发相关功能。服务报错时遵循EOP标准返回错误代码。</p>
<h3 id="工号、授权和认证"><a href="#工号、授权和认证" class="headerlink" title="工号、授权和认证"></a>工号、授权和认证</h3><p>统一工号和认证平台提供工号的开通、角色定义、授权、认证、单点登录、用户资料自维护等功能，各系统不再分配工号，不再重复开发相关功能。</p>
<h3 id="APP框架"><a href="#APP框架" class="headerlink" title="APP框架"></a>APP框架</h3><p>各种APP应该基于统一的框架进行开发，一点解决app开发中遇到的共性问题，比如跨终端开发，集成后端通用能力，app监控等。</p>
<h2 id="第九部分：开发过程中的其他要求"><a href="#第九部分：开发过程中的其他要求" class="headerlink" title="第九部分：开发过程中的其他要求"></a>第九部分：开发过程中的其他要求</h2><h3 id="接口SLA"><a href="#接口SLA" class="headerlink" title="接口SLA"></a>接口SLA</h3><p><font color=red size=4>必须：</font><br>在谈接口之前双方系统需要就以下内容达成一致，并在设计中予以考虑</p>
<ul>
<li>跨团队服务调用均应事先约定好吞吐量、时延、错误率、并发连接数（与吞吐量无关，但便于调用方合理配置）。</li>
<li>服务提供方应设置用户级的流控。</li>
<li>非实时业务应与实时业务使用不同的用户/队列，从而区分流控策略。例如：政企批量业务、统一业务开通，与一般渠道客户参与的业务办理应区分。</li>
<li>各模块应有明确的预期处理性能，当业务变化等因素导致负载超出设计性能时，应及时调整设计和部署方案。</li>
<li>服务调用方应根据服务的一般响应时间和业务容忍时间设置合适的超时时间。</li>
</ul>
<h3 id="密码管理"><a href="#密码管理" class="headerlink" title="密码管理"></a>密码管理</h3><ul>
<li>不得在代码、配置文件中明文填写数据库用户和口令</li>
<li>通过多个文件分离开发和测试环境的配置，避免开发与测试数据相连</li>
</ul>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul>
<li>主流业务处理模块、系统核心模块应100%被单元测试覆盖。</li>
<li>上线前必须经过覆盖主要业务场景的冒烟测试。冒烟测试尽可能通过自动化手段实现。</li>
<li>新部署的节点应经过测试确认能参与业务处理并承担预期的负载。</li>
</ul>
<h3 id="维护作业计划管理"><a href="#维护作业计划管理" class="headerlink" title="维护作业计划管理"></a>维护作业计划管理</h3><p>上线前须在ITSM系统中制定保证系统稳定运行的维护作业计划，并监控执行过程和结果。</p>
<h3 id="变更管理"><a href="#变更管理" class="headerlink" title="变更管理"></a>变更管理</h3><ul>
<li>所有用来构建生产环境、保证生产系统运行（包括维护工具）的代码和配置数据均应保存在企信部统一提供的配置管理服务器中。</li>
<li>所有的代码提交应保证编译和单元测试通过。</li>
<li>所有的生产环境变更应有相应的需求或问题修复任务单，并经过项目组审核</li>
</ul>
<h3 id="版本构建与发布"><a href="#版本构建与发布" class="headerlink" title="版本构建与发布"></a>版本构建与发布</h3><ul>
<li>测试版本、正式版本所用的代码必须100%来自于配置管理服务器。</li>
<li>应在镜像库中保持至少2个稳定历史版本的镜像，并使之处于随时可以发布的状态。</li>
<li>具备在完全不同的全新环境下15分钟内部署当前和上一个稳定版本的能力。</li>
<li>对用户体验影响大的系统，应支持灰度发布，能在线调整不同版本的分流比例和部署规模。</li>
<li>版本发布前应通过安全检查。</li>
<li>对生产有影响的版本变更必须有回退方案。当发现严重问题时，应执行回退而不是尝试在线修复bug（版本回退可以通过不断演练保证很高的成功率，而在线修复bug结果很难预料）。</li>
<li>对用户有影响的版本发布应提前发出通知，说明变更内容。</li>
</ul>
<h3 id="敏感数据存储和访问"><a href="#敏感数据存储和访问" class="headerlink" title="敏感数据存储和访问"></a>敏感数据存储和访问</h3><ul>
<li>敏感信息应存放在单独的数据库或用户下，仅通过API提供访问。</li>
<li>所有的对外暴露服务均应对调用者有认证和权限控制，敏感信息须流量加密。</li>
</ul>
<h2 id="第十部分：关于java开发规范"><a href="#第十部分：关于java开发规范" class="headerlink" title="第十部分：关于java开发规范"></a>第十部分：关于java开发规范</h2><p>java的开发规范，基本上可以参照阿里的<code>java开发手册</code>，各项目根据实际情况进行修改。<br>在开发的IDE比如Idea和Eclipse中安装插件，<code>Alibaba Java Coding Guidelines</code>，然后进行代码扫描。也可以在Jenkins中集成相关插件<code>sonar-p3c-pmd</code>,在编译流水线中进行扫描和生成报告。</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Chloe</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://childgrown.github.io/2020/07/02/wuzhihua/">https://childgrown.github.io/2020/07/02/wuzhihua/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/07/19/iops/">磁盘IOPS和传输带宽</a>
            
            
            <a class="next" rel="next" href="/2020/06/22/openSourceCourses/">开源人才教程小tips</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Chloe | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
